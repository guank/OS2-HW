\documentclass[letterpaper,10pt,draftclsnofoot,onecolumn]{IEEEtran}

\usepackage{graphicx}                                     
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}
\usepackage{listings}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{textcomp}
\usepackage[margin=0.75in]{geometry}

\parindent = 0.0 in
\parskip = 0.1 in

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\begin{document}

\title{Processes, Threading and CPU Scheduling}

\author{
\IEEEauthorblockN{George Crary}
\IEEEauthorblockA{\\Operating Systems II\\Spring 2017}
}

\maketitle
\begin{abstract}
Between the Windows, Linux and FreeBSD operating systems many similarities exist as they fundamentally try to achieve the same things however differences do still exist. This analysis inspects these details and the origins that led to them. While both FreeBSD and Linux share lineage from Unix (Linux via Minix), Windows does not obviously. The result of these differences can be interpreted by the organizational style and control that they come from. For example the Linux development team is purely concerned with the Linux kernel itself while the FreeBSD organization involves itself with both kernel development and core system utilities. FreeBSD in comparison to Linux is subject to a more structured design as a result of this. Microsoft on other hand has development interests from the Windows kernel all the way out to userland and their design commitments reflect that. Additionally the historical environment that these operating systems were developed in also have an influence worth noting. FreeBSD`s Unix ancestors hail from the days of the 16-bit PDP11 while FreeBSD and Linux began their lives on the x86 platform. Windows began targeting x86 with the release of Windows NT as well.
\end{abstract}
\pagebreak

\tableofcontents
\pagebreak
\section{Processes}
Processes throughout the operatings systems contain a large amount of similarities. Throughout the implementations of such concept all of them share such things as program code, open file descriptors, signaling and threading facilities. In addition other living aspects of the program are stored in a process such as run time, threads that are being executed, a data section for global variables and a private virtual address space for its given threads. Information for the CPU scheduler is also maintained within the process data structure as well. For FreeBSD and Linux these similarities are contained in their respective task\textunderscore struct data structure and are very similar as result of being Unix derivatives. In Windows these details are contained in the Windows Executive Process structure, also known as the EPROCESS structure. On top of that some process related data in Windows such as the Process Environment Block live in userland address space for accessibility reasons which is another difference \cite{russinovich}.\\
Within the Unix realms FreeBSD and Linux both begin new processes with a fork system call. The fork calling process is turned into a parent process while the newly forked process is called a child process. In FreeBSD this can involve the rfork system call, which can handle controlling which resources get shared between the parent and child, while on Linux this is similarly handled with the clone system call \cite{love}. Once the child process is up and running an exec system call can be made to run an entirely different program. This exec call overlays the program into the program’s address space and begins executing it. The separation of these two system calls allows for any necessary preparation and cleanup to take place before the new program runs. Windows handles process creation in a similar fashion however it’s much more streamlined. Within Windows CreateProcess gets called and handles identifying the application type. As Windows supports executing Win16, Posix, MS-DOS executables these must be handled additionally with the standard exe executables. In those respective situations the appropriate Windows support image is executed and handled from there \cite{russinovich}. These differences between process creation really speak to the philosophical differences of the operating systems. The fork and exec system calls used in Linux and FreeBSD highlight the mindset of ''Do one thing right and do it well'' and showcases the composition of powerful and concise utilities. The Microsoft way of doing things showcases a commitment to backwards compatibility and total control by consolidating process creation into a single interface.
\par

\newpage
\section{Threading}
Threading is a common concept to all three operating systems. Significant differences begin to show however between Windows and the Unix related operating systems. Even within the Unix family threading is different. Threads are a facility for multiple paths of execution for a given process to occur at a single time while allowing for process resources to be shared. On a multicore machine this means threads can run in parallel potentially which enables a concurrent model of programming for a process. Within the Linux world threads are just seen as special processes and aren’t scheduled in a particularly different way. Within FreeBSD threads are looked upon as lightweight processes as context switching between threads is considerably faster than a context switch between processes \cite{mccusick}. Windows has a similar notion of threads as lightweight processes but also provides a userland scheduled threading facility called Fibers and another concept known as jobs. Jobs simply represent a collection of processes that are to be managed together.\\
Across the Unix systems the threading support is largely standardized thanks to POSIX’s pthreads library.\\
\lstinputlisting[caption=Small Pthreads example in the Unix environment., style=customc]{pthread_example.c}
One of the largest similarities between the three operating systems when it comes to threading is the User mode and Kernel mode distinction. Threads can operate in either User mode and Kernel mode and have their own respective access levels to address spaces. The user mode limitations to address space can help protect the operating system from exploitation in the event a server thread executing on the behalf of a client goes rogue. Separate stacks for these modes are given to threads as well in order for kernel specific operations to be cleanly supported from user mode operations.
\newpage
\section{CPU Scheduling}
CPU Scheduling is a common source of difference between the three operating systems. As the operating system must schedule the order of processes and thread operation across limited computing resources different approaches arise. Each operating system provides facilities for giving processes and threads different levels of priorities. In Linux for example this consists of a niceness value ranging from -20 to +19 with 0 as the default value. In FreeBSD this value ranges from 0 to 255 with different priority classes existing to serve the needs of user mode and kernel mode threads. Windows implements priority across the range 0 to 32 with the greater half representing real time priority levels and the lower end representing variable levels with 0 reserved for the zero page thread \cite{russinovich}.\\
The schedulers behind each of these operating systems are drastically different. After Linux kernel version 2.5 was released a constant time scheduler, also known as the O(1) scheduler, was used. This scheduler could determine the next process to be ran in constant time. This behavior benefited high process count workloads seen on big iron workstations for example as the previous algorithm wasted a lot of time running in linear time. By version 2.6 this was changed to a new scheduler named CFS, the completely fair scheduler \cite{love}. To handle scheduling fairness better CFS divides the processor time uniformly across N processes and then weighs given times appropriately with respect to the relative nice values.\\
FreeBSD uses the ULE scheduler which is named after a filename pun. This scheduler is divided into two schedulers. The low level scheduler and the high level scheduler. The former handles selecting a new thread to run from a non-empty run queue in a round robin fashion whenever a thread blocks \cite{mccusick}. The high level scheduler handles run queues for each CPU and maintaining the thread priorities. The Windows scheduler is similar to the ULE scheduler in terms of its high level CPU concerns and low level task picking. In Window`s case however processor affinity is used to handle the high level case of where a thread may be executed.
\newpage

\newpage
\section{IO Introduction}
The input output (IO) subsystem to any operating system is fundamental to achieving any meaningful “real world” computation. In the before times programs were simply loaded, ran and the result was dumped out at the end for inspection. Of course overtime more interactive facilities for providing input state to programs became developed.\\

To support different IO devices of differing standards, specifications and vendors the concept of device drivers eventually became a thing. These drivers would handle controlling the underlying hardware while providing a software api for the operating system to interact with. These drivers support all sorts of IO devices from spinning hard drive disks to keyboard devices.\\

Within the Unix realm there’s a common philosophy \cite{love} that everything is a file. While this isn’t exactly true, sockets for example aren’t necessarily files, but most things can act like files thanks to file descriptors which unites the common file-esque access patterns across all devices. This approach provides a consistent and reusable interface and mentality to developing within Unix that has contributed to its longevity as an operating system. With everything as a file as the developing mentality utilities from decades ago can remain largely stable, maintainable and interoperable with other programs and especially other devices of any kind. Once a driver for a device has been written any program can act with it in that common way with a relative degree of smoothness.\\

Windows on the other hand doesn’t subscribe to this philosophy at all and it’s really a matter of Unix’s origin as a OS made by developers for developers. From an operating system designer’s standpoint it’s a lot easier to get developers to use your operating system if you simply tell every new user (for Unix’s case these were other developers within Bell Lab’s) to just treat everything as a file. Obviously this approach is simplistic despite it mulling over internal aspects, it worked tremendously as far as growing a community of hardcore enthusiasts willing to hack on Unix and derivatives to what it is today. As for Windows, this kind of user base growth wasn’t necessary nor wanted as internal APIs and order could be created for their own developers and its target customer base had no need to interact with everything as a file.\\

In Linux this philosophy can be applied to IO devices, as devices files, but there is an underlying distinction between block devices that spit back chunks of data in blocks and character devices that return streams of characters. In FreeBSD however this isn’t the case. \cite{freebsdarch} Support for block devices were dropped since caching for disk block devices reorders writes making it hard to know what has been physically committed to disk in the event of a crash recovery. This is a strong example of FreeBSD’s design philosophy.\\

\newpage
\section{Driver Models}
Across both Unix and Windows a device interaction interface is provided. Within the Windows realm of things this is called the Windows Driver Model known as the WDM. The WDM was a kernel change introduced in Windows 2000. Within Linux this is similarly called the Linux Kernel Device Model. For Windows however drivers are written using the Windows Driver Kit towards the WDM standard that all hardware devices and their accompanying software drivers have to comply with. The Windows Driver Model at a high level also includes many stipulations for power management and the “Plug and Play” model of device usage. \cite{russinovich} The primary goal of this is to increase usability from an average user’s standpoint (everyone knows how to plug a device in and play) while reducing complexities overall for software developer as far as supporting devices on a driver by driver basis.\\

\section{Async IO}
Asynchronous IO is also a facility provided by the Windows and the ‘Nix’s on top of regular IO. Also known as Async IO, it allows for a program to dispatch an IO request and continue execution. FreeBSD and Linux are extremely similar in this aspect as they both implement the POSIX api for async io. Windows on the other hand provides support for this using IRP, known as I/O request packets.\\

\section{Dynamically Loadable Modules}
Between both Windows and the Unix’s facilities for dynamically loaded modules are available. In Windows these are called dynamically linked libraries, aka DLL’s, and within Linux these are are called shared object files (with the .so extension). The advantage of dynamically loaded modules is that they can expose and provide system functionality between multiple programs without requiring the duplication of static code. Without DLL’s or shared objects each program binary would involve lugging around its own library code which would increase the overall size of all binaries throughout the system. Additionally when multiple drivers mutually use common functions this is called stacked device drivers. This concept is common to Windows, Linux and FreeBSD.\\

\section{IO Scheduling}
When it comes to scheduling IO operations stark differences between the operating systems begin to appear. IO scheduling is an important issue when it comes to handling physical devices as many IO devices such as platter spinning hard drives need to actuate a read head across the disk’s cylinders. As the the read head is actuated it seeks to whatever sector it’s trying to read. Naive IO schedulers can cause the read head to waste time seeking between sectors when this activity can be optimized to reduce the total range of motion for the seek head and increase the lifespan of the device. Optimizations as such can increase the throughput of IO reads and writes overall however fairness is a consideration that comes into play. As in most cases it’s not just a single process making tons of different requests, its multiple processes doing their requests. In the event that requests get served unfairly a process might become IO starved and wait too long for it. Therefore in Linux the default scheduler is the CFQ, Completely Fair Queuing scheduler, that tries to completely be fair by dividing up IO time in nanoseconds based on the requesting processes \cite{love}. FreeBSD on the other hand uses a CLook elevator scheduler \cite{mccusick}. Lastly Windows has a priority based IO scheduler similar to its process scheduler \cite{russinovich}.\\

\section{Disk Hibernation}
In terms of physical device features Disk Hibernation is a common feature to all three operating systems. Disk Hibernation consists of the saving the operating system’s to disk and powering it off during periods of long inactivity to conserve power. This can be useful for spare drives on a system that aren’t in use as there’s no reason to keep spinning platters.\\

In Windows however this a much more prominent feature as Windows in general had an early lifecycle targeted more towards your average consumer, laptops including, so power consumption is a larger focus. This is in contrast to the server mainframe customer base of Unix’s early history where time.\\

\bibliographystyle{IEEEtran}
\bibliography{ref}
\end{document}
